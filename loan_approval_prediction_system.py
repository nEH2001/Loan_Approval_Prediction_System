# -*- coding: utf-8 -*-
"""Loan_Approval_Prediction_System.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1emllVhbl2ffdLT2WSwevVoTgGAcCp-UV

**Importing the libraries**
"""

import pandas as pd
import numpy as np
import seaborn as sns
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn import svm

"""**Importing the dataset csv file**"""

loan_dataset = pd.read_csv("/loan_dataset.csv")

"""**Load the first 5 rows from the dataset**

"""

loan_dataset.head()

"""**Finding the descriptive measures of the data**"""

loan_dataset.describe()

"""**Finding out the missing values from each of the columns**"""

loan_dataset.isnull().sum()

"""*As the number of missing values are small in count, instead of replacing it with mean or any other component, we will drop the whole rows which has missing values.*

**Dropping the missing values from the dataset**
"""

loan_dataset =loan_dataset.dropna()
loan_dataset.shape

"""*After dropping the missing values, we are left with 480 observations for the further analysis.*

**Replacing the character values of the Loan_Status column into numeric for analysis**
"""

loan_dataset = loan_dataset.replace({"Loan_Status":{"N":0,"Y":1}})

"""**Visualizing the relationship between education and the loan status**"""

sns.countplot(x="Education", hue="Loan_Status", data= loan_dataset)

"""*From the above plot we can interpret that the count of graduate individuals is more as compared to the non-graduate individuals for the approval of loan.*

**Visualizing the relationship between marital status and the loan status**
"""

sns.countplot(x="Married",hue="Loan_Status", data=loan_dataset)

"""*From the above plot we can interpret that the count of married individuals is more as compared to the unmarried individuals for the approval of loan.*

**Finding the number of different values of the Dependents variable/column.**
"""

loan_dataset["Dependents"].value_counts()

"""*Here there is a count of 41 for the value "3+". The value is not an integer type and therefore there may arise trouble ahead while analysing. It's better to change it to a number, i.e. 4.*

**Changing the value from Dependents column**
"""

loan_dataset = loan_dataset.replace(to_replace="3+", value=4)

#Checking if the value has been changed
loan_dataset["Dependents"].value_counts()

"""**Finding the number of different values of the Property_Area variable/column.**"""

loan_dataset["Property_Area"].value_counts()

"""**Changing the categorical values from the dataset to numerical values, so that prediction becomes easier**"""

loan_dataset = loan_dataset.replace({"Gender":{"Male":0,"Female":1},"Married":{"Yes":1,"No":0},
                                     "Education":{"Graduate":1,"Not Graduate":0},
                                     "Self_Employed":{"Yes":1,"No":0},
                                     "Property_Area":{"Urban":1,"Rural":2,"Semiurban":3}})
print(loan_dataset)

"""**Dropping the Loan_ID column and dividing the whole dataset into sub-datasets X and Y, where X has all the variables except Loan_Status and Y has only Loan_Status.**"""

X = loan_dataset.drop(["Loan_ID","Loan_Status"],axis=1)
Y = loan_dataset["Loan_Status"]
print(X)
print(Y)

"""**Train Test Split**"""

#Here X and Y are again splitted into test and train datasets.
#test_size tells us about how much proportion of the whole data we want to keep it for testing
#stratify=Y is used to split the data in Y equally into stratas.
#random_state is used to tell the state of randomness
X_train , X_test , Y_train , Y_test = train_test_split(X,Y, test_size = 0.1, stratify=Y,
                                                       random_state=3)

#To find the shape of the datasets X, X_train, X_test
print(X.shape,X_train.shape, X_test.shape)

""" **Training the model.
Here we make use of the Support Vector Machine model.**
"""

# SVC is the support vector classifier
classifier = svm.SVC(kernel="linear")

#training the model
#X_train has values, Y_train has labels
classifier.fit(X_train,Y_train)

"""**Model Evaluation**"""

#to find the accuracy scores on training data
X_train_prediction = classifier.predict(X_train)
training_data_accuracy = accuracy_score(X_train_prediction,Y_train)
print("Accuracy on training data :" , training_data_accuracy)

#to find the accuracy scores on testing data
X_test_prediction = classifier.predict(X_test)
testing_data_accuracy = accuracy_score(X_test_prediction,Y_test)
print("Accuracy on testing data :" , testing_data_accuracy)

"""*From the above found accuracis on training and testing data, we can say that the model is a very good fit as the accuracy is greater than 70%, and also both the accuracy percentages differ by a percent or so.*

**Making a loan predictive system**
"""

#here you can use your own data to predict the outcome
input_data = ()

#changing the input_data to a numpy array
input_data_as_numpy_array = np.asarray(input_data)

#reshape the np array as we are predicting for one instance
input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)

prediction = classifier.predict(input_data_reshaped)
print(prediction)

if (prediction[0]==1):
  print("The loan is approved")
else:
  print("The loan is not approved")